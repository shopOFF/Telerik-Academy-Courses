namespace _04.PrinciplesInOOP
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    //public class Inheritance
    //{
    // Имате си един много базов клас, който описва вичко общо между всикчи негови деца!!!(В скобите са пропъртитата на отделните класове)
    // НАпример имаме базов клас Person(с имейл и Име)-всеки човек има име и имейл (според нас), той се наследява от други 3 класа(Teacher(какво преподава), Student(студентски номер), Employee(ID и каква точно работа има итн))
    // Teacher пък има други 2 класа който наследяват него(SchoolTeacher(кое училище преподава) и UniversityProfessor(в кой уни, преподава)) и тн.. Employee пък бива наследен от SeniorEmployee(години стаж) и тн ..

    //КЛАСОВЕТЕ СИ ИМАТ НЯКАКВИ СЪСТОЯНИЯ И ПОВЕДЕНИЕ(ДЕЙСТВИЯ КОЙТО ИЗПЪЛНЯВАТ)-(FIELDS, PROPERTIES, METHODS И ТН.)! СЪСТОЯНИЯТА СА НЯКАКВИ ТЕКУЩИ(ЗАСПАЛ ЛИ СЪМ, ГЛАДЕН ЛИ СЪМ И ТН)!!!
    // ДЕЙСТВИЯТА СА ( КАТО В РЕАЛНИЯ СВЯТ ДЕЙСТВИЯ ПРОМЕНЯТ МОЕТО СЪСТОЯНИЕ - СТАВАМ ОТ ЛЕГЛОТО И ТН ).

    // ПРИ НАСЛЕДЯВАНЕТО- ЩОМ ДЕЦАТА НА ДАДЕН КЛАС СА ГО НАСЛЕДИЛИ ПОЛУЧАВАТ ВС НЕГОВИ ХАРАКТЕРИСТИКИ(ПРОПЪРТИТА,ФИЛДОВЕ, МЕТОДИ АБСОЛЮТНО ВСИЧКО), И ПО НИКАКЪВ НАЧИН НЕ МОЖЕТЕ ДА ИЗТРИЕТЕ НЕЩО ВЕЧЕ НАСЛЕДЕНО!!!!
    // НО МОЖЕТЕ ДА ДОБАВЯТЕ ДОПЪЛНИТЕЛНИ ХАРАКТЕРИСТИКИ И ФУНКЦИОНАЛНОСТ!!!

    //        Inheritance: Important Aspects
    //Structures cannot be inherited
    //In C# there is no multiple inheritance
    //Only multiple interfaces can be implemented
    //Static members are also inherited  // Като статичен клас, може да бъде наследяван само от друг статичен клас!
    //Constructors are not inherited      // ТЕ ПРОСТО СЕ ПРЕНАПИСВАТ!!!!!!!!!!!!
    //Inheritance is transitive relation
    //If C is derived from B, and B is derived from A, then C inherits A as well

    //        Inheritance: Important Features
    //When a derived class extends its base class
    //It can freely add new members  // МОЖЕТЕ ДА ДОБАВЯТЕ НОВИ, НО НЕ МОЖЕТЕ ДА ИЗТРИВАТЕ ВЕЧЕ НАСЛЕДЕНИТЕ
    //Cannot remove derived ones     // НЕ МОЖЕТЕ ДА ИЗТРИВАТЕ ВЕЧЕ НАСЛЕДЕНИТЕ
    //Declaring new members with the same name or signature hides the inherited ones
    //A class can declare virtual methods and properties // ВИРТУАЛНИТЕ МЕТОДИ И ПРОПЪРТИТА 
    //Derived classes can override the implementation of these members  (КОГАТО НЕЩО Е ВИРТУАЛНО, ИЗРИЧНО КАЗВАТЕ, ЧЕ НЯКОИ ОТ НАСЛЕДНИЦИТЕ МОГЪТ ДА ПРОМЕНЯТ ЛОГИКАТА!,КАТО OVERRIDE TOSTRING СЕ ПРАВИ!)
    //E.g.Object.ToString() is virtual method       //ТУКА ЗА public override string ToString()  НАЙ-ЧЕСТО ЩЕ ПОЛЗВАМЕ И ЗА ИЗПИТА НА-ВЕРОЯТЪНО

    #region INTERFACES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // Interfaces - ИНТЕРФЕЙСТИТЕ(ТЕ ДЕФИНИРАТ НЯКАКВИ  ОПЕРАЦИИ, КОИТО МОГЪТ ДА СЕ ИЗПОЛЗВАТ, НО ПО НИКАКЪВ НАЧИН НЕ КАЗВАТ, КАК ТИЯ ОПЕРАЦИИ ЩЕ СЕ ИЗПЪЛНЯВАТ)(обикновенно те показват, какво ще бъде публично в класа) И 
    // напраиме: public interface IFigure { void Draw(); } - тоест интерфейса, някаква фигура в нашата игра да кажем- всичките трябва да имат имплементиран метод Draw, който не връща нищо
    // тоест всички фигуи имат свойството(метода, бихейвиъра) да се рисуват по екрана и когато кажа, ей тоя правоъгълник ми е фигура, задължително трява да му имплементирам това нещо.
    // ТОЕСТ ИНТЕРФЕЙСА САМО КАЗВА ТИ КАКВИ СВОЙСТВА ДЕФИНИРАШ(КАКВИ ПРОПЪРТИТА И КАКВИ МЕТОДИ), САМО ГО КАЗВА, ИЗРЕЖДА НАКАКВИ НЕЩА, КОЙТО ТИ ТРЯБВА ДА ИМПЛЕМЕНТИРАШ, АКО НАСЛЕДИШ
    // ТОЯ ИНТЕРФЕЙС. ИЗПОЛЗВА СЕ ПО НЯКАКЪВ НАЧИН ДА МУ КАЖЕШ, ЧЕ ИСКАШ ДА АБСТРАКТНЕШ НЯКАКЪВ ОБЕКТ(С ДР ДУМИ ДА МУ КАЖЕШ- ИСКАМ ДА ИЗПОЛЗВАМ ВС ТВОЙ ИМПЛЕМЕНТАЦИИ). НАПРИМЕР IEnumerable Е ИНТЕРФЕЙС
    // КОЙТО ДАВА FOREACH-ВАНЕ НИЩО ДРУГО, ТОЙ КАЗВА ЩОМ ИМОЛЕМЕНТИРАШ IEnumerable ЗНАЧИ МОЖЕ ДА СЕ ФОРИЙЧВАШ. ЗАТОВА И ПОВЧЕТО КОЛЕКЦИИ ИМПЛЕМЕНТИРАТ IEnumerable, НО НИКАДЕ В ТОЯ IEnumerable НЕ СЕ КАЗВА КАК 
    // РАБОТИ FOREACH!!!!! ПРОСТО СЕ КАЗВА ТИ ИМАШ ЕНУМЕРАТОР И ТОЯ FOREACH МОЖЕ ДА ГО ВЪРТИ, ТВА Е!!!!!!!!!!!!!ПО НИКАКЪВ НАЧИН НЕ КАЗВА КАК СЕ ПРАВИ ТОВА НЕЩО
    // ТОЕСТ АКО ИМАМЕ КЛАС СИСТЕМА(ТЕЛЕРИК АКАДЕМИ), ТОЙ МОЖЕ ДА ИМА ИНТЕРФЕЙСИ (ЗАПИСВАНЕ НА КУРС, ОТПИСВАНЕ НА КУРС, ХОДЕНЕ НА ЛЕКЦИИ, ДОБАВЯНЕ НА РЕСУР И ТН) КАТО ПО НИКАКЪВ НАЧИН ТЕЗИ ИНТЕРФЕЙСИ НЕ КАЗВАТ
    // КАК СЕ ПРАВЯТ ТЕЗИ НЕЩА(НЯМАТ САМАТА ЛОГИКА В ТЯХ)!!! И КОГАТО СЕ НАСЛЕДИ НЯКОЕ ОТ ТЯХ, ТРЯБВА ДА СЕ ИМПЛЕМЕНТИРА, КОДА НЯМА ДА СЕ КОМПИЛИРА ДОКАТО НЕ ИМПЛЕМЕНТИРАТЕ ВСИЧКИ НЕГОВИ МЕТОДИ(ЗАЩОТО СТЕ КАЗАЛИ, ИСКАМ VOID DRAW И ТН(), НО
    // ПО НИКАКЪВ НАЧИН НЕ СТЕ КАЗАЛИ КАК ТОВА НЕЩО СЕ ИМПЛЕМЕНТИРА(КАК ТАЯ ФУГУРА СЕ ХВАЩА И РИСУВА ВСЪЩНОСТ) !!!!!!!!!!!! ИНТЕРФЕЙСТИТЕ СА МНОГО ПОЛЕЗИНИ!
    // ТЕРМИНОЛОГИЯТА Е : ЕДИН КЛАС НАСЛЕДЯВА БАЗОВ КЛАС(ДЕЦАТА НАСЛЕДЯВАТ БАЗОВИЯ КЛАС ИЛИ РОДИТЕЛСКИЯ КЛАС). АКО НАСЛЕДЯВАТЕ ИНТЕРФЕЙС ТЕРМИНА Е ИМПЛЕМЕНТИРА ИНТЕРФЕЙС(ЗАЩОТО ВИЕ РЕАЛНО ИМПЛЕМ..НЯКАКВИ МЕТОДИ, ЗАДАДЕНИ КАТО ИМЕ). 
    // И МОЖЕТЕ ЕДИН ИНТЕРФЕЙС ДА РАЗШИРЯВА ДРУГ ИНТЕРФЕЙС(И В 3-ТЕ СИ Е ЧИСТО НАСЛЕДЯВАНЕ, САМО ТЕРМИНОЛОГИЯТА Е РАЗЛИЧНА). Интерфейсите винаги са с I отпред, за да ги различаваме по-лесно!
    // ВСИЧКО КОЕТО СЕ ДЕФИНИРА В ИНТЕРФЕЙСА СЕ ПРИЕМА ЗА ПУБЛИЧНО!!!
    // derived class INHERTITS base class/ parent class
    // class IMPLEMENTS interface
    // derived class EXTENDS base interface

    //        Inheritance has a lot of benefits
    //Extensibility
    //Reusability(code reuse)
    //Provides abstraction // ТОВА Е МНОГО ВАЖНО 
    //Eliminates redundant code
    //Use inheritance for buidling is-a relationships
    //E.g.dog is-a animal(dogs are kind of animals)
    //Don't use it to build has-a relationship
    //E.g.dog has-a name(dog is not kind of name)

    //    Inheritance leads to a hierarchies of classes
    //    and / or interfaces in an application:

    // МНОГО ВАЖНО ЗА ИНТЕРФЕЙСИТЕ + ПРИМЕР: ТЕ НЕ СА ПРОСТО ШАБЛОНИ, ДАВАТ НИ ВЪЗМОЖНО НАЙ-ДОБРАТА АБСТРАКЦИЯ В СЛУУЧАЙ!!! ПРИМЕРИТЕ ОТДОЛО, СА ОПИСАТЕЛНИ
    //public static void Main()
    //{
    //    var someText = new TextDocument("Nikolin", "Windows1251");
    //    var wrdDoc = new WordDocument("Pesho", "somethig", 1666, "1251", 163);

    //    //Интерфейсите каква им е ролята и на тях.!!!!!!!!!!!!!!!! ВМЕСТО ДА ИЗПОЛЗВАМЕ КОНКРЕТНИ ТИПОВЕ, МНОГО ПО-ДОБРЕ Е(ПО ВЪЗМОЖНОСТ) ДА ИЗПОЛЗВАМЕ ИНТЕРФЕЙСИ!!!
    //    List<Document> allDocs = new List<Document>(); // и големият + е че можем да добавяме вс документи,който наследяват Document, вдигнали сме абстракцията, НО ОЩЕ ПО-ДОБРЕ Е ДА ВДИГНЕМ ОЩЕ ПОВЕЧЕ АБСТР. ЧРЕЗ ИНТЕРФЕЙСА НА ДОКУМЕНТИТЕ НИ, КОЕТО Е НАЙ-ДОБРИЯТ ВАРИАНТ!!!
    //    allDocs.Add(someDoc);
    //    allDocs.Add(someText);
    //    allDocs.Add(wrdDoc);  // и това работи добавяме  WordDocument в лист от Document
    //                          // Има 1 малък недостатък обаче, ако се появи нещо др. което имплементира IDocument, аз не мога да го използвам в този лист,тоест сме ограничени и неможем да си екстендваме функционалността
    //                          // на програмата понеже сме вързани за Document!!! НО МОЖЕМ ДА НАПРАВИМ ТАКА, ДА НАПРАВИМ ЛИСТ ОТ IDocument, ТАКА ВЕЧЕ ВСИЧКО, КОЕТО ИМПЛЕМЕНТИРА IDocument, ВСИЧКО КОЕТО Е ТОЗИ ИНТЕРФЕЙС
    //                          // АЗ МОГА ДА ГО ДОБАВЯМ. ТОВА МИ ПОЗВОЛЯВА ПЕРФЕКТНИЯТ НАЧИН, ДА СИ ЕКСТЕНДВАМ ГОТОВАТА ФУНКЦИОНАЛНОСТ!!!!!!!!!!!!!!!!!!!!! А НЕ САМО WordDocument,BinarDocument... и тн ТЕ ИМПЛЕМЕНТИРАТ IDocument, ЗАТОВА ДИРЕКТНО ВДИГАМЕ АБСТРАКЦИЯТА И ПОЛЗВАМЕ ИНТЕРФЕЙСА!!!
    //    List<IDocument> allInterfaceDocs = new List<IDocument>(); // ETO TAKA!!!!!!!!!!!!!!!!!  
    //    allInterfaceDocs.Add(wrdDoc);  //!!!!!!!!!!!!!!!!!!!!!!!!!



    //    // ТОВА Е за долниите примерИ!!!!!!!!!!! ДА НЕ СЕ БЪРКА С ГОРНИТЕ, РАЗЛИЧНИ НЕЩА ПРАВЯТ!!!
    //    HashSet<int> hesh = new HashSet<int>();
    //    PrintCollection(hesh);
    //}

    // ДРУГО ВАЖНО НЕЩО! НАЙ-ДОЛНИЯТ ПРИМЕР С IEnumerable<int> Е НАЙ-ДОБРИЯТ ВАРИАНТ В СЛУЧАЯ И НАЙ-ДОБРИЯТ ПРИМЕР!!!!!
    // static void PrintCollection(List<int> collection) // НО ПО ТОЗИ НАЧИН СМЕ ВЪРЗАНИ ДИРЕКТНО САМО ЗА ЛИСТОВЕ(НЕМОЖЕ ДА МУ ДАДЕМ МАСИВ, ХЕШСЕТ И ТН). ПОНЕЖЕ САМО foreach-ваме И НЕ ПРАВИМ ДРУГИ НЕЩА С ЛИСТА
    //{                                                  // СПОКОЙНО МОЖЕМ ДА ВДИГНЕМ АБСТРАКЦИЯТА И ДА ГО НАПРАВИМ НА IList
    //    foreach (var number in collection)
    //    {
    //        Console.WriteLine(number);
    //    }
    //}                                                   // IList - НИ ДАВА ИНДЕКСАТОР И ADD, REMOVE O  ОЩЕ MN ДРУГИ ПОЛЕЗНИ НЕЩА !!!!!!
    //static void PrintCollection(IList<int> collection) // ЕТО ВЕЧЕ Е IList, КОЕТО ЩЕ МИ КАЖЕ, ЧЕ ВСИЧКИТЕ КЛАСОВЕ, КОИТО ИМПЛЕМЕНТИРАТ IList МОГА ДА ГИ ПОДАМ ТУК БЕЗ ПРОБЛЕМИ(А МОГА ИДА СИ СЪЗДАМ СОБСТВЕНА СТРУКТУРА, ДА Я НАПРАВЯ ДА НАСЛЕДЯВА ИНТЕРФЕЙСА IList)
    //{                                                  // И ТЯ ВЕЧЕ ЩЕ РАБОТИ. ПО ТОЗИ НАЧИН КАТО ПОДАВАМЕ ИНТЕРФЕЙСИ, ВСЯКО НЕЩО Е МНОГО ПО ЛЕСНО ЕКСТЕНСИБЪЛ(ДА МУ СЕ ДОБАВЯТ НОВИ ФУНКЦИОНАЛСОТИ) И ФЛЕКСИБЪЛ, ПРОСТО ТРЯБВА ДА ИМПЛЕМЕНТИРА ИНТЕРФЕЙСА КОЙТО ИСКАМЕ И ЩЕ РАБОТИ!!!
    //    foreach (var number in collection)              // ЕТО НАПРИМЕР  HashSet НЕ ИМПЛЕМЕНТИРА ИНТЕРФЕЙСА IList(АКО ИСКАМЕ ДА ВИДИМ КОЕ КАКВО ТОЧНО ИМПЛЕМЕНТИРА НАТИСКАМЕ F12 И МОЖЕМ ДА ВИДИМЕ) И НЕ БАЧКА!!! ЗА ДА БАЧКА ТРЯБВА ДА ВДИГНЕМ АБСТРАКЦИЯТА, ЗА ДА ГО ПОЛЗВАМЕ ТУК(В СЛУЧАЯ НИ ТРЯБВА САМО foreach ЗАТОВА Е ОК ДА ВДИГНЕМ АБСТРАКЦИЯТА, АКО НИ ТРЯБВА И ДРУГА ФУНКЦИОНАЛСНОТ ВЕЧЕ Е ДР ВЪПРОС)!!!! 
    //    {                                               // И СЛЕД КАТО ПОЛЗВАМЕ САМО foreach, ЩЕ Е ГЛУПАВО ДА ПРАВИМ ОТДЕЛЕН МЕТОД ЗА HashSet ИЛИ ДР Set(СЕТ КОЛЕКЦИИ), КОИТО ИМПЛЕМЕНТИРАТ ISet, ЗАТОВА НАЙ ДОБРЕ ДА СИ ВДИГНЕМ АБСТРАКЦИЯТА ТАКА(С ТАКЪВ ИНТЕРФЕЙС), ЧЕ ДА МОЖЕ ДА СЕ ПОЛЗВА ОТ ПОВЕЧЕТО КОЛЕКЦИИ(ПОВЕЧЕТО КОЛЕКЦИИ ИМАТ foreach, ЯВНО ИМПЛЕМЕНТИРАТ ОБЩ ИНТЕРФЕЙС, КОЙТО ДАВА ТАЗИ ФУНКЦИОНАЛНОСТ ТОВА Е IEnumerable ТОЙ ПРАВИ ВСЯКО НЕЩО,КОЕТО ГО ИМПЛЕМЕНТИРА ДА МОЖЕ ДА СЕ foreach-ВА!!!)
    //        Console.WriteLine(number);
    //    }
    //}
    // 
    // МОЖЕМ ДА СИ ПОЗВОЛИМ ДА ВДИГНЕМ В СЛУЧАЯ ОЩЕ ПОВЕЧЕ АБСТРАКЦИЯТА(И КАЧВАМЕ ПО ВЪЗМОЖНОСТ АБСТРАКЦИЯТА С ИНТЕРФЕЙС ВИНАГИ!!!!!!!!!(ВСИЧКО КОЕТО ИМПЛЕМЕНТИРА ИНТЕРФЕЙСА ЩЕ МОЖЕ ДА ГО ПОЛЗВАМЕ, А НЕ КОНКРЕТЕН ТИП!!!)), ЗА ДА НЕ НИ СЕ НАЛАГА ДА КОПИРАМЕ КОД(СЪЩИЯТ МЕТОД И ЗА ДР КОЛЕКЦИИ)!!!!!!!!!!!!!!!!!!!
    // ЕТО ТАКА ВДИГАМЕ СИ ОЩЕ АБСТРАКЦИЯТА И ПРАВИМ КОЛЕКЦИЯТА ОТ ТИП IEnumerable<int> КОЕТО НИ ПОЗВОЛЯВА ВЕЧЕ ДА ПОЛЗВАМЕ ВСИЧКО,КОЕТО ИМПЛЕМЕНТИРА IEnumerable(НЕГОВИТЕ ФУНКЦИОНАЛНОСТИ) В СЛУЧАЯ НИ ТРЯБВА foreach КОЙТО ДАВА!!! .ПОПРИНЦИП НАЙ-ДОБРЕ ДА СИ НАПРАВИМ (Generic) ОТ IEnumerable<T> ДА СИ ВДИГНЕМ АБСТРАКЦИЯТА И НА ТИПА ЗА ДА МОЖЕ, МЕТОДА ДА Е ОЩЕ ПО ФЛЕКССАБИЛЕН, ДА РАБОТИ СЪС ВСЯКАКЪВ ТИП!!!!!!
    //static void PrintCollection(IEnumerable<int> collection)   // ТАКА ВЕЧЕ ВСИЧКИ КОЛЕКЦИИ ЩЕ РАБОТЯТ(HashSet, List, SortedSet, Array...........)
    //{
    //    foreach (var number in collection)
    //    {
    //        Console.WriteLine(number);
    //    }
    //}


    //  ВАЖНО:
    // A class can inherit only one base class !!!
    //      E.g.IOException derives from SystemException and it derives from Exception

    // A class can implement several interfaces !!!
    //      This is .NET’s form of multiple inheritance
    //      E.g.List<T> implements IList<T>, ICollection<T>, IEnumerable<T>

    // An interface can implement several interfaces !!!
    //      E.g.IList<T> implements ICollection<T> and IEnumerable<T>

    // Ако искаме да присвойм дадено пропърти или нещо друго от базов клас ПОЛЗВАМЕ : base  ето така
    //        Use the keyword base to invoke the parent constructor
    //  public Circle(int x, int y) : base(x)
    //{ … }

    #endregion

    // ВАЖНО: АКО НАСЛЕДЯВАМЕ ОТ ДАДДЕН КЛАС, САМО ЕДНО НЕЩО НЕ СЕ НАСЛЕДЯВА И ТОВА Е КОНСТРУКТОРА ОТ МАЙЧИНИЯ КЛАС !!! КОПНСТРУКТОРА НЕ БАЧКА ЗА НАСЛЕДНИЦИТЕ
    // И АКО НИ ТРЯБВА МОЖЕ Е ТО ПО ТОЗИ НАЧИН ДАГО ИЗВИКАМЕ :   Use the keyword base to invoke the parent constructor
    //  public Circle(int x, int y) : base(x)
    //{ … }

    // ПРИМЕР: 
    // БАЗОВ КЛАС ...
    public class Mammal
    {
        public int Age { get; set; }  // години..

        public Mammal(int age)   //конструктор: при създаване на нов обект от тип бозайник, задължително трябва да му нашиш на колко години е 
        {
            this.Age = age;
        }

        public void Sleep()
        {
            Console.WriteLine("Shhh! I'm sleeping!");
        }
    }
    // ДЪЩЕРЕН КЛАС, НАСЛЕДНИК...
    public class Dog : Mammal  // кучето наследява бозайника
    {
        public string Breed { get; set; }  // порода да му задаваме

        public Dog(int age, string breed)  // тук му казваме, че освне години искаме конструктора да ни приема и порода, като годините си ги взимаме от базовия клас(констр.на базовия клас)
          : base(age)                      // като да използваме базовия конструктор от базовия клас е най-добрия вариант,като първо ще се изпълни този констр и след това базовия.
        {
            this.Breed = breed;
        }

        public void WagTail()  // кучето си има и специфично действие..
        {
            Console.WriteLine("Tail wagging...");
        }
    }

    //ПРИМЕР ОТ ИЗПИТ : DOCUMENT SYSTEM  , МНОГО ДОБРИ ПРИМЕР ОСОБЕНО ЗА НАСЛЕДЯВАНЕ НА ИНТЕРФЕЙСИ, АБСТРАКЦИЯ ЧРЕЗ ИНТЕРФЕЙСИ И ТН....
}
//}
