namespace DocumentSystem
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    public class DocumentSystemStartUp
    {
        // Първо си създаваме нов клас, Document с необходимите пропъртита и конструктори(задължително име трябва да има) и другите стоойности, които интерфейса, който наследяваме ни задължава да имплементираме!!!
        // Второ си създаваме интерфейс  IDocument, който ще ни задлъжава да имплементираме няколко неща, който имплементираме в главния, базов клас Document!!! И след това ще може да си ползваме интерфейса, за да правим още по-висока абстракция!!!
        // Трето си правим отделен клас за Text-а, който ще се казва TextDocument, той наследява базовия клас(като трябва да вземем задължителното име с конструктор) и интерфейса,
        // Четвърто си добавяме отделен клас за BinaryDocument, който има някакъв Size
        // Пето си добавяме OfficeDocument клас, който наследява BinaryDocument и има някакъв Version
        // Шесто си добавяме WordDocument, който наследява OfficeDocument разбирасе и има и number of characters
        // Седмо, word i exel документите са енкриптъбъл, което означава, че вс такива документи трябва да инплементират IEncryptable интерфейс и трябва да се пази стпойност дали е енкриптед или не и може да се сетва това само през този интерфейс!
        // Осмо, правим си Document абстрактен клас или може би не, няма смисъл в случая

        public static void Main()
        {
            var someDoc = new Document("Nikodim", "E sme6nik");
            var someText = new TextDocument("Nikolin", "Windows1251");

            var wrdDoc = new WordDocument("Pesho", "somethig",1666, "1251", 163);
                                //Интерфейсите каква им е ролята и на тях.!!!!!!!!!!!!!!!! ВМЕСТО ДА ИЗПОЛЗВАМЕ КОНКРЕТНИ ТИПОВЕ, МНОГО ПО-ДОБРЕ Е(ПО ВЪЗМОЖНОСТ) ДА ИЗПОЛЗВАМЕ ИНТЕРФЕЙСИ!!!
            List<Document> allDocs = new List<Document>(); // и големият + е че можем да добавяме вс документи,който наследяват Document, вдигнали сме абстракцията, НО ОЩЕ ПО-ДОБРЕ Е ДА ВДИГНЕМ ОЩЕ ПОВЕЧЕ АБСТР. ЧРЕЗ ИНТЕРФЕЙСА НА ДОКУМЕНТИТЕ НИ, КОЕТО Е НАЙ-ДОБРИЯТ ВАРИАНТ!!!
            allDocs.Add(someDoc);
            allDocs.Add(someText);
            allDocs.Add(wrdDoc);  // и това работи добавяме  WordDocument в лист от Document
                                  // Има 1 малък недостатък обаче, ако се появи нещо др. което имплементира IDocument, аз не мога да го използвам в този лист,тоест сме ограничени и неможем да си екстендваме функционалността
                                  // на програмата понеже сме вързани за Document!!! НО МОЖЕМ ДА НАПРАВИМ ТАКА, ДА НАПРАВИМ ЛИСТ ОТ IDocument, ТАКА ВЕЧЕ ВСИЧКО, КОЕТО ИМПЛЕМЕНТИРА IDocument, ВСИЧКО КОЕТО Е ТОЗИ ИНТЕРФЕЙС
                                  // АЗ МОГА ДА ГО ДОБАВЯМ. ТОВА МИ ПОЗВОЛЯВА ПЕРФЕКТНИЯТ НАЧИН, ДА СИ ЕКСТЕНДВАМ ГОТОВАТА ФУНКЦИОНАЛНОСТ!!!!!!!!!!!!!!!!!!!!! А НЕ САМО WordDocument,BinarDocument... и тн ТЕ ИМПЛЕМЕНТИРАТ IDocument, ЗАТОВА ДИРЕКТНО ВДИГАМЕ АБСТРАКЦИЯТА И ПОЛЗВАМЕ ИНТЕРФЕЙСА!!!
            List<IDocument> allInterfaceDocs = new List<IDocument>(); // ETO TAKA!!!!!!!!!!!!!!!!!  
            allInterfaceDocs.Add(wrdDoc);  //!!!!!!!!!!!!!!!!!!!!!!!!!



            // ТОВА Е за долниите примерИ!!!!!!!!!!! ДА НЕ СЕ БЪРКА С ГОРНИТЕ, РАЗЛИЧНИ НЕЩА ПРАВЯТ!!!
            HashSet<int> hesh = new HashSet<int>();
            PrintCollection(hesh);
        }

        // ДРУГО ВАЖНО НЕЩО!
        // static void PrintCollection(List<int> collection) // НО ПО ТОЗИ НАЧИН СМЕ ВЪРЗАНИ ДИРЕКТНО САМО ЗА ЛИСТОВЕ(НЕМОЖЕ ДА МУ ДАДЕМ МАСИВ, ХЕШСЕТ И ТН). ПОНЕЖЕ САМО foreach-ваме И НЕ ПРАВИМ ДРУГИ НЕЩА С ЛИСТА
        //{                                                  // СПОКОЙНО МОЖЕМ ДА ВДИГНЕМ АБСТРАКЦИЯТА И ДА ГО НАПРАВИМ НА IList
        //    foreach (var number in collection)
        //    {
        //        Console.WriteLine(number);
        //    }
        //}
        //static void PrintCollection(IList<int> collection) // ЕТО ВЕЧЕ Е IList, КОЕТО ЩЕ МИ КАЖЕ, ЧЕ ВСИЧКИТЕ КЛАСОВЕ, КОИТО ИМПЛЕМЕНТИРАТ IList МОГА ДА ГИ ПОДАМ ТУК БЕЗ ПРОБЛЕМИ(А МОГА ИДА СИ СЪЗДАМ СОБСТВЕНА СТРУКТУРА, ДА Я НАПРАВЯ ДА НАСЛЕДЯВА ИНТЕРФЕЙСА IList)
        //{                                                  // И ТЯ ВЕЧЕ ЩЕ РАБОТИ. ПО ТОЗИ НАЧИН КАТО ПОДАВАМЕ ИНТЕРФЕЙСИ, ВСЯКО НЕЩО Е МНОГО ПО ЛЕСНО ЕКСТЕНСИБЪЛ(ДА МУ СЕ ДОБАВЯТ НОВИ ФУНКЦИОНАЛСОТИ) И ФЛЕКСИБЪЛ, ПРОСТО ТРЯБВА ДА ИМПЛЕМЕНТИРА ИНТЕРФЕЙСА КОЙТО ИСКАМЕ И ЩЕ РАБОТИ!!!
        //    foreach (var number in collection)              // ЕТО НАПРИМЕР  HashSet НЕ ИМПЛЕМЕНТИРА ИНТЕРФЕЙСА IList(АКО ИСКАМЕ ДА ВИДИМ КОЕ КАКВО ТОЧНО ИМПЛЕМЕНТИРА НАТИСКАМЕ F12 И МОЖЕМ ДА ВИДИМЕ) И НЕ БАЧКА!!! ЗА ДА БАЧКА ТРЯБВА ДА ВДИГНЕМ АБСТРАКЦИЯТА, ЗА ДА ГО ПОЛЗВАМЕ ТУК(В СЛУЧАЯ НИ ТРЯБВА САМО foreach ЗАТОВА Е ОК ДА ВДИГНЕМ АБСТРАКЦИЯТА, АКО НИ ТРЯБВА И ДРУГА ФУНКЦИОНАЛСНОТ ВЕЧЕ Е ДР ВЪПРОС)!!!! 
        //    {                                               // И СЛЕД КАТО ПОЛЗВАМЕ САМО foreach, ЩЕ Е ГЛУПАВО ДА ПРАВИМ ОТДЕЛЕН МЕТОД ЗА HashSet ИЛИ ДР Set(СЕТ КОЛЕКЦИИ), КОИТО ИМПЛЕМЕНТИРАТ ISet, ЗАТОВА НАЙ ДОБРЕ ДА СИ ВДИГНЕМ АБСТРАКЦИЯТА ТАКА(С ТАКЪВ ИНТЕРФЕЙС), ЧЕ ДА МОЖЕ ДА СЕ ПОЛЗВА ОТ ПОВЕЧЕТО КОЛЕКЦИИ(ПОВЕЧЕТО КОЛЕКЦИИ ИМАТ foreach, ЯВНО ИМПЛЕМЕНТИРАТ ОБЩ ИНТЕРФЕЙС, КОЙТО ДАВА ТАЗИ ФУНКЦИОНАЛНОСТ ТОВА Е IEnumerable ТОЙ ПРАВИ ВСЯКО НЕЩО,КОЕТО ГО ИМПЛЕМЕНТИРА ДА МОЖЕ ДА СЕ foreach-ВА!!!)
        //        Console.WriteLine(number);
        //    }
        //}
        // МОЖЕМ ДА СИ ПОЗВОЛИМ ДА ВДИГНЕМ В СЛУЧАЯ ОЩЕ ПОВЕЧЕ АБСТРАКЦИЯТА(И КАЧВАМЕ ПО ВЪЗМОЖНОСТ АБСТРАКЦИЯТА С ИНТЕРФЕЙС ВИНАГИ!!!!!!!!!(ВСИЧКО КОЕТО ИМПЛЕМЕНТИРА ИНТЕРФЕЙСА ЩЕ МОЖЕ ДА ГО ПОЛЗВАМЕ, А НЕ КОНКРЕТЕН ТИП!!!)), ЗА ДА НЕ НИ СЕ НАЛАГА ДА КОПИРАМЕ КОД(СЪЩИЯТ МЕТОД И ЗА ДР КОЛЕКЦИИ)!!!!!!!!!!!!!!!!!!!
        // ЕТО ТАКА ВДИГАМЕ СИ ОЩЕ АБСТРАКЦИЯТА И ПРАВИМ КОЛЕКЦИЯТА ОТ ТИП IEnumerable<int> КОЕТО НИ ПОЗВОЛЯВА ВЕЧЕ ДА ПОЛЗВАМЕ ВСИЧКО,КОЕТО ИМПЛЕМЕНТИРА IEnumerable(НЕГОВИТЕ ФУНКЦИОНАЛНОСТИ) В СЛУЧАЯ НИ ТРЯБВА foreach КОЙТО ДАВА!!! .ПОПРИНЦИП НАЙ-ДОБРЕ ДА СИ НАПРАВИМ (Generic) ОТ IEnumerable<T> ДА СИ ВДИГНЕМ АБСТРАКЦИЯТА И НА ТИПА ЗА ДА МОЖЕ, МЕТОДА ДА Е ОЩЕ ПО ФЛЕКССАБИЛЕН, ДА РАБОТИ СЪС ВСЯКАКЪВ ТИП!!!!!!
        static void PrintCollection(IEnumerable<int> collection)   // ТАКА ВЕЧЕ ВСИЧКИ КОЛЕКЦИИ ЩЕ РАБОТЯТ(HashSet, List, SortedSet, Array...........)
        {                                                  
            foreach (var number in collection)               
            {                                              
                Console.WriteLine(number);
            }
        }
    }
}
