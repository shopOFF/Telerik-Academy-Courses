namespace VirtualMethodsExample
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    public class StartUp
    {
        static void Main()
        {
            var animal = new Animal();
            animal.Name = "Gesho";
            Console.WriteLine(animal);
            Console.WriteLine(animal.Greet());  // това ни връща все още не презаписания метод

            var dog = new Dog();  // създаваме нов обект от куче 
            Console.WriteLine(dog.Greet());  // и вече, като извикаме метода греет, той вече е презаписан от метода в кучето  + ТОВА КОЕТО ИМА В БАЗОВИЯ МЕТОД!!!

            var cat = new Cat();    // създаваме нов обект котка
            Console.WriteLine(cat.Greet());  // и вече, като извикаме метода греет, той вече е презаписан от метода в котката

            // ЕТО ТАКА СЕ ПРАВИ И ПРЕЗАПИСВА ВИРТУАЛЕН МЕТОД!!!!!
            // ВИРТУАЛНИТЕ МЕТОДИ- ИМЛЕМЕНТИРАЛ СЪМ ГИ В БАЗОВИЯ КЛАС, ОБАЧЕ ВСИЧКИТЕ НАСЛЕДНИЦИ МОГЪТ ДА ИМ КАЖАТ ДА СЕ ПРОМЕНЯТ И КАК ТОЧНО!!!МОГЪТ И ДА НЕ ИМ КАЖАТ ДА СЕ ПРОМЕНЯТ.позволено ни е и да не го презаписваме, тъй като вече ни е имплементиран в базовия клас!!!
            // ХЕМ НАСЛЕДЯВАМЕ ВСИЧКО ОТ ЖИВОТНОТО, НО СЕ КАЗВА, АБЕ ТВА НЕЩО Е РАЗЛИЧНО  И СЕ ДЪРЖИ ПО ДРУГ НАЧИН!!!

            // ето пример със змя която ще наследява всичко от анимал и няма да презаписва виртуалния метод!
            var snake = new Snake();
            Console.WriteLine(snake.Greet());  // и ще ни изписва просто "I am an animal"
            Console.WriteLine("-------Next examples-------");
            // ето това е полиморфизъм(с базовия клас, ползваме всички по-долни)
            var animals = new List<Animal>();  // лист от общит клас животни(и тъй като те всички са животни наследяват анимал, можем без проблеми да си ги дабавим в листа и да ги използваме)
            animals.Add(animal);
            animals.Add(snake);
            animals.Add(dog);
            animals.Add(cat);

            foreach (var item in animals)
            {
                Console.WriteLine(item.Greet());   // и така всяко си принтира собствения гриид метод, нищо че листа е от тип животно- в него ме му добавили наследниците му (кучета, котки итн) и ние си работим с тях
            }

            // НЕДОСТАТЪК НА ТОЯ ПОЛИМОРФИЗЪМ Е: ДА РЕЧЕМ ДА СИ ДОБАВИМ ДРУГ МЕТОД В КОТКАТА (Sleep) И ДРУГ В КУЧЕТО(Run). ПРОБЛЕМЪТ Е ЧЕ СЛЕД КАТО КОТКАТА ГО ИМПЛЕМЕНТИРА ТОЯ 
            // МЕТОД СЛИИП и кучето импле.- Run, ние за съжаление ги нямаме тези методи в полиморфизма (item.  -- и ги нямаме тук,няма как да ги ползваме!!!)(като си фориичваме листа, ги нямаме!).
            // ЗАЩОТО НИЕ СИ ИЗПОЛЗВАМЕ РЕАЛНО БАЗОВИЯ КЛАС, НИЩО ЧЕ КОГАТО ИЗВИКАМЕ КОНКРЕТЕН МЕТОД, ВСЕКИ СЕ СЪОБРАЗЯВА ДАЛИ ТОЙ НЕ Е КАЗАЛ НЕЩО ДРУГО ЗА ТОЗИ МЕТОД(ДАЛИ НЕ ГО Е ОУВЪРРАЙТНАЛ)!!!!!!!!!
            // ТАКА ЧЕ ПОНЯКОГА КОЛКОТО И ДА НЕ НИ СЕ ЩЕ, СЕ НАЛАГА ДА СИ НАПРАВИМ ОТДЕЛНИ КОЛЕКЦИИ ЗА ОТДЕЛНИТЕ КЛАСОВЕ ЗА ДА ИМ ПОЛЗВАМЕ ПЪЛНАТА ФУНКЦИОНАЛНОСТ. ЕТО ТАКА:
            var cats = new List<Cat>();
            var dogs = new List<Dog>();



            // ИЛИ МОЖЕМ ДА НАПРАВИМ ДРУГО С IF ВЪВ ФОРИИЧ МЕТОДА ДА СИ ГИ ОТСЕЕМ ЕТО ТАКА: НО ТОВА Е МНОГО ГРЕШНО ОТ КЪМ КПК!!!
            // НЕ ГО ПРАВЕТЕ!!!!!!!!!!!!!
            //foreach (var item in animals)
            //{
            //    Console.WriteLine(item.Greet());   

            //    if (item is Cat)
            //    {
            //        var someCat = (Cat)item;
            //        someCat.Sleep();
            //    }
            //}

            // ИМА И 3-ТИ ВАРИАНТ ОТНОВО НЕ Е ДОБЪР ВАРИАНТ!!!
            //foreach (var item in animals)
            //{
            //    Console.WriteLine(item.Greet());

            //        var someCat = item as Cat;
            //        someCat.Sleep();
            //}
        }
    }
}
